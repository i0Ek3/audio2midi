<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éŸ³é¢‘è½¬ç®€è°±å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
        }
        
        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        .upload-section {
            background: #f8f9ff;
            border: 2px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s;
        }
        
        .upload-section:hover {
            border-color: #764ba2;
            background: #f0f2ff;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .upload-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 40px;
            border: none;
            border-radius: 50px;
            font-size: 1.1em;
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        .file-info {
            margin-top: 20px;
            color: #555;
            font-size: 1.1em;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-success {
            background: #48bb78;
            color: white;
        }
        
        .btn-info {
            background: #4299e1;
            color: white;
        }
        
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .status {
            background: #e6fffa;
            border-left: 4px solid #48bb78;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            display: none;
        }
        
        .editor-section {
            margin-top: 30px;
        }
        
        .editor-label {
            font-size: 1.2em;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }
        
        #jianpuEditor {
            width: 100%;
            min-height: 200px;
            padding: 20px;
            font-size: 1.3em;
            font-family: 'Courier New', monospace;
            border: 2px solid #667eea;
            border-radius: 10px;
            resize: vertical;
            line-height: 1.8;
        }
        
        .info-box {
            background: #fff5e6;
            border-left: 4px solid #f59e0b;
            padding: 15px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .info-box h3 {
            color: #f59e0b;
            margin-bottom: 10px;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error {
            background: #fee !important;
            border-color: #f00 !important;
            color: #c00;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸµ éŸ³é¢‘è½¬ç®€è°±å·¥å…·</h1>
        
        <div class="upload-section">
            <input type="file" id="audioFile" accept="audio/*">
            <button class="upload-btn" onclick="document.getElementById('audioFile').click()">
                ğŸ“ é€‰æ‹©éŸ³é¢‘æ–‡ä»¶
            </button>
            <div class="file-info" id="fileInfo"></div>
        </div>
        
        <div class="controls">
            <button class="btn btn-primary" id="analyzeBtn" disabled onclick="analyzeAudio()">
                ğŸ¼ åˆ†æå¹¶ç”Ÿæˆç®€è°±
            </button>
            <button class="btn btn-success" id="saveTextBtn" disabled onclick="saveAsText()">
                ğŸ’¾ ä¿å­˜ä¸ºæ–‡æœ¬
            </button>
            <button class="btn btn-info" id="saveMidiBtn" disabled onclick="saveAsMidi()">
                ğŸ¹ å¯¼å‡ºMIDI
            </button>
        </div>
        
        <div class="status" id="status"></div>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>æ­£åœ¨åˆ†æéŸ³é¢‘...</p>
        </div>
        
        <div class="info-box">
            <h3>ä½¿ç”¨è¯´æ˜</h3>
            <p>â€¢ æ”¯æŒä¸Šä¼ MP3ã€WAVç­‰å¸¸è§éŸ³é¢‘æ ¼å¼</p>
            <p>â€¢ å•æ—‹å¾‹æ•ˆæœæœ€ä½³,å¤æ‚å’Œå£°å¯èƒ½éœ€è¦æ‰‹åŠ¨è°ƒæ•´</p>
            <p>â€¢ ç®€è°±æ ¼å¼: 1-7è¡¨ç¤ºéŸ³é«˜, -è¡¨ç¤ºå»¶é•¿, 0è¡¨ç¤ºä¼‘æ­¢ç¬¦</p>
            <p>â€¢ ä½éŸ³ç”¨ä¸‹åˆ’çº¿æ ‡è®°(å¦‚ 1Ì²), é«˜éŸ³ç”¨ç‚¹æ ‡è®°(å¦‚ 1Ì‡)</p>
            <p>â€¢ ç”Ÿæˆåå¯åœ¨ç¼–è¾‘å™¨ä¸­æ‰‹åŠ¨ä¿®æ”¹,ç„¶åå¯¼å‡º</p>
        </div>
        
        <div class="editor-section">
            <div class="editor-label">ç®€è°±ç¼–è¾‘å™¨:</div>
            <textarea id="jianpuEditor" placeholder="åˆ†æå®Œæˆå,ç®€è°±å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ,æ‚¨å¯ä»¥æ‰‹åŠ¨ç¼–è¾‘..."></textarea>
        </div>
    </div>

    <script>
        let audioContext;
        let audioBuffer;
        let currentJianpu = '';
        
        // åˆå§‹åŒ–
        document.getElementById('audioFile').addEventListener('change', handleFileSelect);
        
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            document.getElementById('fileInfo').textContent = `å·²é€‰æ‹©: ${file.name}`;
            document.getElementById('analyzeBtn').disabled = false;
            
            // åŠ è½½éŸ³é¢‘
            const reader = new FileReader();
            reader.onload = function(e) {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                audioContext.decodeAudioData(e.target.result, function(buffer) {
                    audioBuffer = buffer;
                    showStatus('éŸ³é¢‘åŠ è½½æˆåŠŸ!', 'success');
                }, function(e) {
                    showStatus('éŸ³é¢‘è§£ç å¤±è´¥,è¯·å°è¯•å…¶ä»–æ ¼å¼', 'error');
                    console.error('Decode error:', e);
                });
            };
            reader.readAsArrayBuffer(file);
        }
        
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.style.display = 'block';
            if (type === 'error') {
                status.classList.add('error');
            } else {
                status.classList.remove('error');
            }
        }
        
        async function analyzeAudio() {
            if (!audioBuffer) {
                showStatus('è¯·å…ˆä¸Šä¼ éŸ³é¢‘æ–‡ä»¶', 'error');
                return;
            }
            
            document.getElementById('loading').style.display = 'block';
            document.getElementById('analyzeBtn').disabled = true;
            
            // ä½¿ç”¨ setTimeout è®© UI æœ‰æ—¶é—´æ›´æ–°
            setTimeout(() => {
                try {
                    const jianpu = performPitchDetection(audioBuffer);
                    currentJianpu = jianpu;
                    document.getElementById('jianpuEditor').value = jianpu;
                    document.getElementById('saveTextBtn').disabled = false;
                    document.getElementById('saveMidiBtn').disabled = false;
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('analyzeBtn').disabled = false;
                    showStatus('ç®€è°±ç”Ÿæˆå®Œæˆ! æ‚¨å¯ä»¥åœ¨ä¸‹æ–¹ç¼–è¾‘å™¨ä¸­ä¿®æ”¹', 'success');
                } catch (e) {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('analyzeBtn').disabled = false;
                    showStatus('åˆ†æå‡ºé”™: ' + e.message, 'error');
                    console.error('Analysis error:', e);
                }
            }, 100);
        }
        
        function performPitchDetection(buffer) {
            const channelData = buffer.getChannelData(0);
            const sampleRate = buffer.sampleRate;
            
            // æ”¹è¿›çš„åˆ†æå‚æ•°
            const frameSize = 4096;
            const hopSize = Math.floor(sampleRate * 0.1); // æ¯0.1ç§’åˆ†æä¸€æ¬¡
            const notes = [];
            
            for (let i = 0; i < channelData.length - frameSize; i += hopSize) {
                const frame = channelData.slice(i, i + frameSize);
                
                // è®¡ç®—RMSèƒ½é‡
                const rms = Math.sqrt(frame.reduce((sum, val) => sum + val * val, 0) / frame.length);
                
                if (rms > 0.02) { // æé«˜é˜ˆå€¼ï¼Œå‡å°‘å™ªéŸ³
                    const pitch = detectPitchYIN(frame, sampleRate);
                    if (pitch > 0 && pitch < 2000) { // æœ‰æ•ˆéŸ³é«˜èŒƒå›´
                        const note = frequencyToJianpu(pitch);
                        notes.push(note);
                    } else {
                        notes.push('-');
                    }
                } else {
                    notes.push('0'); // ä¼‘æ­¢ç¬¦
                }
            }
            
            // æ¸…ç†å’Œæ ¼å¼åŒ–
            const cleaned = cleanupNotes(notes);
            return formatJianpu(cleaned);
        }
        
        // æ”¹è¿›çš„YINç®—æ³•éŸ³é«˜æ£€æµ‹
        function detectPitchYIN(buffer, sampleRate) {
            const threshold = 0.1;
            const bufferSize = buffer.length;
            const halfBufferSize = Math.floor(bufferSize / 2);
            
            const yinBuffer = new Float32Array(halfBufferSize);
            
            // æ­¥éª¤1: è®¡ç®—å·®åˆ†å‡½æ•°
            yinBuffer[0] = 1.0;
            let runningSum = 0;
            
            for (let tau = 1; tau < halfBufferSize; tau++) {
                yinBuffer[tau] = 0;
                for (let i = 0; i < halfBufferSize; i++) {
                    const delta = buffer[i] - buffer[i + tau];
                    yinBuffer[tau] += delta * delta;
                }
            }
            
            // æ­¥éª¤2: ç´¯ç§¯å½’ä¸€åŒ–
            for (let tau = 1; tau < halfBufferSize; tau++) {
                runningSum += yinBuffer[tau];
                yinBuffer[tau] *= tau / runningSum;
            }
            
            // æ­¥éª¤3: æ‰¾åˆ°ç¬¬ä¸€ä¸ªä½äºé˜ˆå€¼çš„ç‚¹
            let tau = 1;
            while (tau < halfBufferSize - 1) {
                if (yinBuffer[tau] < threshold) {
                    while (tau + 1 < halfBufferSize && yinBuffer[tau + 1] < yinBuffer[tau]) {
                        tau++;
                    }
                    break;
                }
                tau++;
            }
            
            if (tau === halfBufferSize - 1 || yinBuffer[tau] >= threshold) {
                return -1;
            }
            
            // æ­¥éª¤4: æŠ›ç‰©çº¿æ’å€¼
            let betterTau = tau;
            if (tau > 0 && tau < halfBufferSize - 1) {
                const s0 = yinBuffer[tau - 1];
                const s1 = yinBuffer[tau];
                const s2 = yinBuffer[tau + 1];
                betterTau = tau + (s2 - s0) / (2 * (2 * s1 - s2 - s0));
            }
            
            return sampleRate / betterTau;
        }
        
        function frequencyToJianpu(freq) {
            // C4 = 261.63 Hz ä½œä¸ºåŸºå‡†éŸ³ (ç®€è°±çš„ 1)
            const C4 = 261.63;
            
            // è®¡ç®—åŠéŸ³æ•°å·®å¼‚
            const semitones = 12 * Math.log2(freq / C4);
            const roundedSemitones = Math.round(semitones);
            
            // ç¡®å®šå…«åº¦
            const octave = Math.floor(roundedSemitones / 12);
            const noteIndex = ((roundedSemitones % 12) + 12) % 12;
            
            // åŠéŸ³åˆ°ç®€è°±çš„æ˜ å°„ (Cå¤§è°ƒ)
            const noteMap = [
                '1',  // C  (0)
                '1#', // C# (1)
                '2',  // D  (2)
                '2#', // D# (3)
                '3',  // E  (4)
                '4',  // F  (5)
                '4#', // F# (6)
                '5',  // G  (7)
                '5#', // G# (8)
                '6',  // A  (9)
                '6#', // A# (10)
                '7'   // B  (11)
            ];
            
            let note = noteMap[noteIndex];
            
            // æ·»åŠ å…«åº¦æ ‡è®°
            if (octave < 0) {
                note = note + 'Ì²'; // ä½éŸ³ç‚¹ (å®é™…æ˜¾ç¤ºå¯èƒ½å› å­—ä½“è€Œå¼‚)
            } else if (octave > 0) {
                note = note + 'Ì‡'; // é«˜éŸ³ç‚¹
            }
            
            return note;
        }
        
        function cleanupNotes(notes) {
            const result = [];
            let i = 0;
            
            while (i < notes.length) {
                const note = notes[i];
                
                // è·³è¿‡è¿ç»­çš„ä¼‘æ­¢ç¬¦,åªä¿ç•™ä¸€ä¸ª
                if (note === '0') {
                    result.push('0');
                    while (i + 1 < notes.length && notes[i + 1] === '0') {
                        i++;
                    }
                } 
                // è·³è¿‡è¿ç»­çš„å»¶é•¿ç¬¦
                else if (note === '-') {
                    if (result.length > 0 && result[result.length - 1] !== '-') {
                        result.push('-');
                    }
                }
                // æ™®é€šéŸ³ç¬¦
                else {
                    result.push(note);
                }
                
                i++;
            }
            
            return result;
        }
        
        function formatJianpu(notes) {
            let formatted = '// è°ƒå·: C  æ‹å·: 4/4\n';
            formatted += '// å»ºè®®: ç”Ÿæˆç»“æœå¯èƒ½éœ€è¦æ‰‹åŠ¨è°ƒæ•´èŠ‚å¥å’ŒéŸ³é«˜\n\n';
            
            // æ¯è¡Œ8ä¸ªéŸ³ç¬¦(ä¾¿äºé˜…è¯»)
            for (let i = 0; i < notes.length; i += 8) {
                const line = notes.slice(i, i + 8);
                formatted += line.join(' ') + '\n';
            }
            
            return formatted;
        }
        
        function saveAsText() {
            try {
                const content = document.getElementById('jianpuEditor').value;
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'jianpu_' + Date.now() + '.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showStatus('æ–‡æœ¬æ–‡ä»¶å·²ä¿å­˜!', 'success');
            } catch (e) {
                showStatus('ä¿å­˜å¤±è´¥: ' + e.message, 'error');
                console.error('Save text error:', e);
            }
        }
        
        function saveAsMidi() {
            try {
                const content = document.getElementById('jianpuEditor').value;
                const midiData = convertToMidi(content);
                
                if (!midiData) {
                    throw new Error('MIDIè½¬æ¢å¤±è´¥');
                }
                
                const blob = new Blob([midiData], { type: 'audio/midi' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'jianpu_' + Date.now() + '.mid';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showStatus('MIDIæ–‡ä»¶å·²å¯¼å‡º! å¯å¯¼å…¥Logic Proä½¿ç”¨', 'success');
            } catch (e) {
                showStatus('MIDIå¯¼å‡ºå¤±è´¥: ' + e.message, 'error');
                console.error('Save MIDI error:', e);
            }
        }
        
        function convertToMidi(jianpuText) {
            try {
                // è§£æç®€è°±
                const lines = jianpuText.split('\n').filter(line => !line.startsWith('//') && line.trim());
                const noteEvents = [];
                let currentTime = 0;
                const ticksPerBeat = 480;
                const defaultDuration = ticksPerBeat; // å››åˆ†éŸ³ç¬¦
                
                lines.forEach(line => {
                    const symbols = line.split(/\s+/).filter(s => s);
                    
                    symbols.forEach(symbol => {
                        if (symbol === '0') {
                            // ä¼‘æ­¢ç¬¦
                            currentTime += defaultDuration;
                        } else if (symbol === '-') {
                            // å»¶é•¿ä¸Šä¸€ä¸ªéŸ³ç¬¦
                            if (noteEvents.length > 0) {
                                noteEvents[noteEvents.length - 1].duration += defaultDuration;
                            }
                            currentTime += defaultDuration;
                        } else {
                            // æ™®é€šéŸ³ç¬¦
                            const midiNote = jianpuToMidiNote(symbol);
                            if (midiNote >= 0 && midiNote <= 127) {
                                noteEvents.push({
                                    time: currentTime,
                                    note: midiNote,
                                    duration: defaultDuration,
                                    velocity: 80
                                });
                                currentTime += defaultDuration;
                            }
                        }
                    });
                });
                
                if (noteEvents.length === 0) {
                    throw new Error('æ²¡æœ‰æœ‰æ•ˆçš„éŸ³ç¬¦');
                }
                
                return createMidiFile(noteEvents, ticksPerBeat);
            } catch (e) {
                console.error('Convert to MIDI error:', e);
                throw e;
            }
        }
        
        function jianpuToMidiNote(symbol) {
            // ç§»é™¤æ‰€æœ‰æ ‡è®°,è·å–åŸºç¡€éŸ³ç¬¦
            const cleanSymbol = symbol.replace(/[Ì²Ì‡Ìˆ#]/g, '').replace(/[^\d]/g, '');
            
            // Cå¤§è°ƒç®€è°±åˆ°MIDIéŸ³ç¬¦çš„æ˜ å°„ (ä¸­å¤®C = 60)
            const baseNotes = {
                '1': 60,  // C4
                '2': 62,  // D4
                '3': 64,  // E4
                '4': 65,  // F4
                '5': 67,  // G4
                '6': 69,  // A4
                '7': 71   // B4
            };
            
            let midiNote = baseNotes[cleanSymbol];
            
            if (!midiNote) {
                return 60; // é»˜è®¤è¿”å›C4
            }
            
            // å¤„ç†å‡é™å·
            if (symbol.includes('#')) {
                midiNote += 1;
            }
            
            // å¤„ç†å…«åº¦
            if (symbol.includes('Ì²')) {
                midiNote -= 12; // ä½å…«åº¦
            } else if (symbol.includes('Ì‡')) {
                midiNote += 12; // é«˜å…«åº¦
            } else if (symbol.includes('Ìˆ')) {
                midiNote += 24; // è¶…é«˜å…«åº¦
            }
            
            // ç¡®ä¿åœ¨æœ‰æ•ˆèŒƒå›´å†…
            return Math.max(0, Math.min(127, midiNote));
        }
        
        function createMidiFile(noteEvents, ticksPerBeat) {
            // MIDIæ–‡ä»¶å¤´
            const header = [
                0x4D, 0x54, 0x68, 0x64, // "MThd"
                0x00, 0x00, 0x00, 0x06, // å¤´éƒ¨é•¿åº¦
                0x00, 0x00,             // æ ¼å¼0
                0x00, 0x01,             // 1ä¸ªéŸ³è½¨
                (ticksPerBeat >> 8) & 0xFF, ticksPerBeat & 0xFF  // æ¯æ‹çš„tickæ•°
            ];
            
            // åˆ›å»ºéŸ³è½¨æ•°æ®
            const trackEvents = [];
            
            // è®¾ç½®é€Ÿåº¦ (120 BPM)
            trackEvents.push(0x00, 0xFF, 0x51, 0x03, 0x07, 0xA1, 0x20);
            
            // æ·»åŠ éŸ³ç¬¦äº‹ä»¶
            let lastTime = 0;
            noteEvents.forEach(event => {
                const deltaTime = event.time - lastTime;
                const dtBytes = encodeVariableLength(deltaTime);
                
                // Note On
                trackEvents.push(...dtBytes, 0x90, event.note, event.velocity);
                
                // Note Off
                const durationBytes = encodeVariableLength(event.duration);
                trackEvents.push(...durationBytes, 0x80, event.note, 0x40);
                
                lastTime = event.time + event.duration;
            });
            
            // éŸ³è½¨ç»“æŸæ ‡è®°
            trackEvents.push(0x00, 0xFF, 0x2F, 0x00);
            
            // éŸ³è½¨å¤´
            const trackHeader = [
                0x4D, 0x54, 0x72, 0x6B, // "MTrk"
                (trackEvents.length >> 24) & 0xFF,
                (trackEvents.length >> 16) & 0xFF,
                (trackEvents.length >> 8) & 0xFF,
                trackEvents.length & 0xFF
            ];
            
            // ç»„åˆå®Œæ•´çš„MIDIæ–‡ä»¶
            return new Uint8Array([...header, ...trackHeader, ...trackEvents]);
        }
        
        function encodeVariableLength(value) {
            const bytes = [];
            bytes.push(value & 0x7F);
            value = value >> 7;
            
            while (value > 0) {
                bytes.unshift((value & 0x7F) | 0x80);
                value = value >> 7;
            }
            
            return bytes;
        }
    </script>
</body>
</html>

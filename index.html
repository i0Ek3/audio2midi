<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>éŸ³é¢‘è½¬ç®€è°±å·¥å…·</title>
        <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
        }
        
        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.5em;
        }
        
        .upload-section {
            background: #f8f9ff;
            border: 2px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s;
        }
        
        .upload-section:hover {
            border-color: #764ba2;
            background: #f0f2ff;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .upload-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 40px;
            border: none;
            border-radius: 50px;
            font-size: 1.1em;
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        .file-info {
            margin-top: 20px;
            color: #555;
            font-size: 1.1em;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-success {
            background: #48bb78;
            color: white;
        }
        
        .btn-danger {
            background: #f56565;
            color: white;
        }
        
        .btn-info {
            background: #4299e1;
            color: white;
        }
        
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .status {
            background: #e6fffa;
            border-left: 4px solid #48bb78;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            display: none;
        }
        
        .status.error {
            background: #fee;
            border-color: #f00;
            color: #c00;
        }
        
        .editor-section {
            margin-top: 30px;
        }
        
        .editor-label {
            font-size: 1.2em;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }
        
        #jianpuEditor {
            width: 100%;
            min-height: 200px;
            padding: 20px;
            font-size: 1.3em;
            font-family: 'Courier New', monospace;
            border: 2px solid #667eea;
            border-radius: 10px;
            resize: vertical;
            line-height: 1.8;
        }
        
        .info-box {
            background: #fff5e6;
            border-left: 4px solid #f59e0b;
            padding: 15px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .info-box h3 {
            color: #f59e0b;
            margin-bottom: 10px;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .code-box {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.5;
        }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>ğŸµ éŸ³é¢‘è½¬ç®€è°±å·¥å…·</h1>
            <div class="upload-section">
                <input type="file" id="audioFile" accept="audio/*">
                <button class="upload-btn" onclick="document.getElementById('audioFile').click()">
                    ğŸ“ é€‰æ‹©éŸ³é¢‘æ–‡ä»¶
                </button>
                <div class="file-info" id="fileInfo"></div>
            </div>
            <div class="controls">
                <button
                    class="btn btn-primary"
                    id="analyzeBtn"
                    disabled
                    onclick="analyzeAudio()"
                >
                    ğŸ¼ åˆ†æå¹¶ç”Ÿæˆç®€è°±
                </button>
                <button
                    class="btn btn-success"
                    id="playBtn"
                    disabled
                    onclick="playJianpu()"
                >
                    â–¶ï¸ æ’­æ”¾ç®€è°±
                </button>
                <button
                    class="btn btn-success"
                    id="stopBtn"
                    disabled
                    onclick="stopJianpu()"
                    style="background: #f56565;"
                >
                    â¹ï¸ åœæ­¢æ’­æ”¾
                </button>
                <button
                    class="btn btn-success"
                    id="saveTextBtn"
                    disabled
                    onclick="saveAsText()"
                >
                    ğŸ’¾ ä¿å­˜ä¸ºæ–‡æœ¬
                </button>
                <button
                    class="btn btn-info"
                    id="saveMidiBtn"
                    disabled
                    onclick="saveAsMidi()"
                >
                    ğŸ¹ å¯¼å‡ºMIDI
                </button>
            </div>
            <div class="status" id="status"></div>
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>æ­£åœ¨åˆ†æéŸ³é¢‘...</p>
            </div>
            <div class="info-box">
                <h3>ä½¿ç”¨è¯´æ˜</h3>
                <p>â€¢ æ”¯æŒä¸Šä¼ MP3ã€WAVç­‰å¸¸è§éŸ³é¢‘æ ¼å¼</p>
                <p>â€¢ å•æ—‹å¾‹æ•ˆæœæœ€ä½³,å¤æ‚å’Œå£°å¯èƒ½éœ€è¦æ‰‹åŠ¨è°ƒæ•´</p>
                <p>â€¢ ç®€è°±æ ¼å¼: 1-7è¡¨ç¤ºéŸ³é«˜, -è¡¨ç¤ºå»¶é•¿, 0è¡¨ç¤ºä¼‘æ­¢ç¬¦</p>
                <p>â€¢ ä½éŸ³ç”¨ä¸‹åˆ’çº¿æ ‡è®°(å¦‚ 1Ì²), é«˜éŸ³ç”¨ç‚¹æ ‡è®°(å¦‚ 1Ì‡)</p>
                <p>â€¢ ç”Ÿæˆåå¯åœ¨ç¼–è¾‘å™¨ä¸­æ‰‹åŠ¨ä¿®æ”¹,ç„¶åå¯¼å‡º</p>
            </div>
            <div class="editor-section">
                <div class="editor-label">ç®€è°±ç¼–è¾‘å™¨:</div>
                <textarea id="jianpuEditor" placeholder="åˆ†æå®Œæˆå,ç®€è°±å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ,æ‚¨å¯ä»¥æ‰‹åŠ¨ç¼–è¾‘..."></textarea>
            </div>
        </div>
        
        <script>
        let audioContext;
        let audioBuffer;
        let currentJianpu = '';
        let isPlaying = false;
        let playbackNodes = [];

        // ================== æ ¸å¿ƒæ’­æ”¾å‡½æ•° ==================
        
        // 1. ä¸»æ’­æ”¾å‡½æ•° - playJianpu()
        function playJianpu() {
            console.log('playJianpu å‡½æ•°è¢«è°ƒç”¨');
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        playJianpuInternal();
                    });
                } else {
                    playJianpuInternal();
                }
            } catch (e) {
                showStatus('æ’­æ”¾å¤±è´¥: ' + e.message, 'error');
                console.error('playJianpu é”™è¯¯:', e);
            }
        }

        // 2. å†…éƒ¨æ’­æ”¾é€»è¾‘ - playJianpuInternal()
        function playJianpuInternal() {
            console.log('playJianpuInternal è¢«è°ƒç”¨');
            try {
                const content = document.getElementById('jianpuEditor').value;
                if (!content || !content.trim()) {
                    showStatus('è¯·å…ˆç”Ÿæˆç®€è°±', 'error');
                    return;
                }
                
                const noteEvents = parseJianpuToNotes(content);
                if (!noteEvents || noteEvents.length === 0) {
                    showStatus('æ²¡æœ‰æœ‰æ•ˆçš„éŸ³ç¬¦å¯ä»¥æ’­æ”¾', 'error');
                    return;
                }
                
                console.log('å¼€å§‹æ’­æ”¾ï¼Œå…± ' + noteEvents.length + ' ä¸ªéŸ³ç¬¦');
                
                isPlaying = true;
                document.getElementById('playBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                playbackNodes = [];
                
                const bpm = 120;
                const beatDuration = 60 / bpm;
                const startTime = audioContext.currentTime + 0.1;
                
                noteEvents.forEach((event, index) => {
                    const noteStartTime = startTime + event.time * beatDuration;
                    const duration = Math.max(0.05, event.duration * beatDuration);
                    
                    if (event.note > 0) {
                        const delayMs = Math.max(0, (noteStartTime - audioContext.currentTime) * 1000);
                        setTimeout(() => {
                            if (isPlaying) {
                                console.log('æ’­æ”¾éŸ³ç¬¦: ' + index);
                                scheduleNote(event.note, audioContext.currentTime, duration, event.velocity);
                            }
                        }, delayMs);
                    }
                });
                
                const totalDuration = Math.max(...noteEvents.map(e => (e.time + e.duration) * beatDuration));
                setTimeout(() => {
                    if (isPlaying) {
                        stopJianpu();
                    }
                }, (totalDuration + 0.5) * 1000);
                
                showStatus('æ­£åœ¨æ’­æ”¾ç®€è°±...', 'success');
            } catch (e) {
                showStatus('æ’­æ”¾å¤±è´¥: ' + e.message, 'error');
                console.error('playJianpuInternal é”™è¯¯:', e);
            }
        }

        // 3. éŸ³ç¬¦åˆæˆå‡½æ•° - scheduleNote()
        function scheduleNote(midiNote, startTime, duration, velocity) {
            try {
                const frequency = 440 * Math.pow(2, (midiNote - 69) / 12);
                const volume = velocity / 127 * 0.2;
                
                const oscillator = audioContext.createOscillator();
                const envelope = audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.value = frequency;
                
                const now = audioContext.currentTime;
                envelope.gain.setValueAtTime(0, now);
                envelope.gain.linearRampToValueAtTime(volume, now + 0.01);
                
                if (duration > 0.1) {
                    envelope.gain.exponentialRampToValueAtTime(volume * 0.5, now + duration - 0.05);
                }
                
                envelope.gain.linearRampToValueAtTime(0, now + duration);
                
                oscillator.connect(envelope);
                envelope.connect(audioContext.destination);
                
                oscillator.start(now);
                oscillator.stop(now + duration);
                
                playbackNodes.push(oscillator);
                playbackNodes.push(envelope);
                
                console.log('æ’­æ”¾: MIDI ' + midiNote + ' (' + frequency.toFixed(2) + 'Hz), æ—¶é•¿ ' + duration.toFixed(3) + 's');
            } catch (e) {
                console.error('scheduleNote é”™è¯¯:', e);
            }
        }

        // 4. åœæ­¢æ’­æ”¾å‡½æ•° - stopJianpu()
        function stopJianpu() {
            console.log('stopJianpu è¢«è°ƒç”¨');
            try {
                if (isPlaying) {
                    playbackNodes.forEach((node) => {
                        try {
                            node.stop(audioContext.currentTime);
                        } catch (e) {
                            console.log('èŠ‚ç‚¹å·²åœæ­¢');
                        }
                    });
                    playbackNodes = [];
                }
                
                isPlaying = false;
                document.getElementById('playBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                showStatus('æ’­æ”¾å·²åœæ­¢', 'success');
            } catch (e) {
                console.error('stopJianpu é”™è¯¯:', e);
            }
        }

        // 5. ç®€è°±è§£æå‡½æ•° - parseJianpuToNotes()
        function parseJianpuToNotes(content) {
            console.log('parseJianpuToNotes è¢«è°ƒç”¨');
            const mapping = {
                '1': 60, '2': 62, '3': 64, '4': 65, '5': 67, '6': 69, '7': 71,
            };

            const tokens = content
                .replace(/\|/g, ' ')
                .replace(/\s+/g, ' ')
                .trim()
                .split(' ');

            const result = [];
            let time = 0;
            for (let token of tokens) {
                if (!token) continue;

                let duration = 1;
                let velocity = 100;
                let note = 0;

                // æ£€æŸ¥æ˜¯å¦ä¸ºä¼‘æ­¢ç¬¦
                if (token.includes('0')) {
                    note = 0;
                } else {
                    // å»é™¤ééŸ³ç¬¦ç¬¦å·
                    const base = token.match(/[1-7]/);
                    if (!base) continue;
                    note = mapping[base[0]];

                    // å¤„ç†å…«åº¦æ ‡è®°
                    const upCount = (token.match(/Â·/g) || []).length;
                    const downCount = (token.match(/,/g) || []).length;
                    note += (upCount * 12) - (downCount * 12);
                }

                // å»¶é•¿ç¬¦ â€œ-â€
                if (token.includes('-')) duration *= 2;

                result.push({ note, time, duration, velocity });
                time += duration;
            }

            console.log('è§£æç»“æœ:', result);
            return result;
        }

        // 6. çŠ¶æ€æ˜¾ç¤ºå‡½æ•°ï¼ˆç¤ºä¾‹ï¼‰
        function showStatus(msg, type) {
            console.log(`[${type}] ${msg}`);
        }
        
        // åˆå§‹åŒ–
        document.getElementById('audioFile').addEventListener('change', handleFileSelect);
        document.getElementById('jianpuEditor').addEventListener('input', function() {
            // å½“ç¼–è¾‘å™¨æœ‰å†…å®¹æ—¶ï¼Œå¯ç”¨æ’­æ”¾æŒ‰é’®
            if (this.value.trim().length > 0) {
                document.getElementById('playBtn').disabled = false;
            }
        });
        
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            document.getElementById('fileInfo').textContent = `å·²é€‰æ‹©: ${file.name}`;
            document.getElementById('analyzeBtn').disabled = false;
            
            // åŠ è½½éŸ³é¢‘
            const reader = new FileReader();
            reader.onload = function(e) {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                audioContext.decodeAudioData(e.target.result, function(buffer) {
                    audioBuffer = buffer;
                    showStatus('éŸ³é¢‘åŠ è½½æˆåŠŸ!', 'success');
                }, function(e) {
                    showStatus('éŸ³é¢‘è§£ç å¤±è´¥,è¯·å°è¯•å…¶ä»–æ ¼å¼', 'error');
                    console.error('Decode error:', e);
                });
            };
            reader.readAsArrayBuffer(file);
        }
        
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.style.display = 'block';
            if (type === 'error') {
                status.classList.add('error');
            } else {
                status.classList.remove('error');
            }
        }
        
        async function analyzeAudio() {
            if (!audioBuffer) {
                showStatus('è¯·å…ˆä¸Šä¼ éŸ³é¢‘æ–‡ä»¶', 'error');
                return;
            }
            
            document.getElementById('loading').style.display = 'block';
            document.getElementById('analyzeBtn').disabled = true;
            
            // ä½¿ç”¨ setTimeout è®© UI æœ‰æ—¶é—´æ›´æ–°
            setTimeout(() => {
                try {
                    const jianpu = performPitchDetection(audioBuffer);
                    currentJianpu = jianpu;
                    document.getElementById('jianpuEditor').value = jianpu;
                    document.getElementById('saveTextBtn').disabled = false;
                    document.getElementById('saveMidiBtn').disabled = false;
                    document.getElementById('playBtn').disabled = false;
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('analyzeBtn').disabled = false;
                    showStatus('ç®€è°±ç”Ÿæˆå®Œæˆ! æ‚¨å¯ä»¥åœ¨ä¸‹æ–¹ç¼–è¾‘å™¨ä¸­ä¿®æ”¹', 'success');
                    console.log('ç®€è°±å·²ç”Ÿæˆï¼Œå†…å®¹é•¿åº¦: ' + jianpu.length);
                } catch (e) {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('analyzeBtn').disabled = false;
                    showStatus('åˆ†æå‡ºé”™: ' + e.message, 'error');
                    console.error('Analysis error:', e);
                }
            }, 100);
        }
        
        function performPitchDetection(buffer) {
            const channelData = buffer.getChannelData(0);
            const sampleRate = buffer.sampleRate;
            
            // æ”¹è¿›çš„åˆ†æå‚æ•° - å…³é”®ä¿®å¤ï¼šä½¿ç”¨æ›´å¤§çš„ hopSize
            const frameSize = 4096;
            const hopSize = Math.floor(sampleRate * 0.25); // æ¯0.25ç§’åˆ†æä¸€æ¬¡ï¼ˆä¹‹å‰0.1ç§’å¯¼è‡´é‡å¤ï¼‰
            const notes = [];
            const pitches = [];
            
            for (let i = 0; i < channelData.length - frameSize; i += hopSize) {
                const frame = channelData.slice(i, i + frameSize);
                
                // è®¡ç®—RMSèƒ½é‡
                const rms = Math.sqrt(frame.reduce((sum, val) => sum + val * val, 0) / frame.length);
                
                if (rms > 0.02) { // æé«˜é˜ˆå€¼ï¼Œå‡å°‘å™ªéŸ³
                    const pitch = detectPitchYIN(frame, sampleRate);
                    if (pitch > 0 && pitch < 2000) { // æœ‰æ•ˆéŸ³é«˜èŒƒå›´
                        pitches.push({ pitch: pitch, rms: rms });
                    } else {
                        pitches.push({ pitch: -1, rms: rms });
                    }
                } else {
                    pitches.push({ pitch: -1, rms: rms }); // ä¼‘æ­¢ç¬¦
                }
            }
            
            // ä½¿ç”¨æ›´æ™ºèƒ½çš„éŸ³ç¬¦åˆ†ç»„æ–¹æ³• - æ£€æµ‹éŸ³é«˜å˜åŒ–
            const notes_grouped = groupNotesByChange(pitches);
            
            // æ¸…ç†å’Œæ ¼å¼åŒ–
            const cleaned = cleanupNotes(notes_grouped);
            return formatJianpu(cleaned);
        }
        
        function groupNotesByChange(pitches) {
            if (pitches.length === 0) return [];
            
            const notes = [];
            let currentNote = null;
            let lastPitch = null;
            const pitchThreshold = 50; // é¢‘ç‡å˜åŒ–50Hzä»¥ä¸Šæ‰è®¤ä¸ºæ˜¯ä¸åŒéŸ³ç¬¦
            
            for (let i = 0; i < pitches.length; i++) {
                const { pitch, rms } = pitches[i];
                
                // åˆ¤æ–­æ˜¯å¦æ˜¯ä¼‘æ­¢ç¬¦
                if (rms < 0.02 || pitch < 0) {
                    if (currentNote !== '0') {
                        notes.push('0');
                        currentNote = '0';
                    }
                    lastPitch = null;
                } 
                // åˆ¤æ–­æ˜¯å¦æ˜¯æ–°çš„éŸ³ç¬¦ï¼ˆéŸ³é«˜å˜åŒ–è¶…è¿‡é˜ˆå€¼ï¼‰
                else if (lastPitch === null || Math.abs(pitch - lastPitch) > pitchThreshold) {
                    const note = frequencyToJianpu(pitch);
                    notes.push(note);
                    currentNote = note;
                    lastPitch = pitch;
                }
                // å¦åˆ™æ˜¯åŒä¸€ä¸ªéŸ³ç¬¦çš„å»¶ç»­ï¼Œä¸æ·»åŠ 
            }
            
            return notes;
        }
        
        // æ”¹è¿›çš„YINç®—æ³•éŸ³é«˜æ£€æµ‹
        function detectPitchYIN(buffer, sampleRate) {
            const threshold = 0.1;
            const bufferSize = buffer.length;
            const halfBufferSize = Math.floor(bufferSize / 2);
            
            const yinBuffer = new Float32Array(halfBufferSize);
            
            // æ­¥éª¤1: è®¡ç®—å·®åˆ†å‡½æ•°
            yinBuffer[0] = 1.0;
            let runningSum = 0;
            
            for (let tau = 1; tau < halfBufferSize; tau++) {
                yinBuffer[tau] = 0;
                for (let i = 0; i < halfBufferSize; i++) {
                    const delta = buffer[i] - buffer[i + tau];
                    yinBuffer[tau] += delta * delta;
                }
            }
            
            // æ­¥éª¤2: ç´¯ç§¯å½’ä¸€åŒ–
            for (let tau = 1; tau < halfBufferSize; tau++) {
                runningSum += yinBuffer[tau];
                yinBuffer[tau] *= tau / runningSum;
            }
            
            // æ­¥éª¤3: æ‰¾åˆ°ç¬¬ä¸€ä¸ªä½äºé˜ˆå€¼çš„ç‚¹
            let tau = 1;
            while (tau < halfBufferSize - 1) {
                if (yinBuffer[tau] < threshold) {
                    while (tau + 1 < halfBufferSize && yinBuffer[tau + 1] < yinBuffer[tau]) {
                        tau++;
                    }
                    break;
                }
                tau++;
            }
            
            if (tau === halfBufferSize - 1 || yinBuffer[tau] >= threshold) {
                return -1;
            }
            
            // æ­¥éª¤4: æŠ›ç‰©çº¿æ’å€¼
            let betterTau = tau;
            if (tau > 0 && tau < halfBufferSize - 1) {
                const s0 = yinBuffer[tau - 1];
                const s1 = yinBuffer[tau];
                const s2 = yinBuffer[tau + 1];
                betterTau = tau + (s2 - s0) / (2 * (2 * s1 - s2 - s0));
            }
            
            return sampleRate / betterTau;
        }
        
        function frequencyToJianpu(freq) {
            // C4 = 261.63 Hz ä½œä¸ºåŸºå‡†éŸ³ (ç®€è°±çš„ 1)
            const C4 = 261.63;
            
            // è®¡ç®—åŠéŸ³æ•°å·®å¼‚
            const semitones = 12 * Math.log2(freq / C4);
            const roundedSemitones = Math.round(semitones);
            
            // ç¡®å®šå…«åº¦
            const octave = Math.floor(roundedSemitones / 12);
            const noteIndex = ((roundedSemitones % 12) + 12) % 12;
            
            // åŠéŸ³åˆ°ç®€è°±çš„æ˜ å°„ (Cå¤§è°ƒ)
            const noteMap = [
                '1',  // C  (0)
                '1#', // C# (1)
                '2',  // D  (2)
                '2#', // D# (3)
                '3',  // E  (4)
                '4',  // F  (5)
                '4#', // F# (6)
                '5',  // G  (7)
                '5#', // G# (8)
                '6',  // A  (9)
                '6#', // A# (10)
                '7'   // B  (11)
            ];
            
            let note = noteMap[noteIndex];
            
            // æ·»åŠ å…«åº¦æ ‡è®°
            if (octave < 0) {
                note = note + 'Ì²'; // ä½éŸ³ç‚¹ (å®é™…æ˜¾ç¤ºå¯èƒ½å› å­—ä½“è€Œå¼‚)
            } else if (octave > 0) {
                note = note + 'Ì‡'; // é«˜éŸ³ç‚¹
            }
            
            return note;
        }
        
        function cleanupNotes(notes) {
            const result = [];
            let i = 0;
            
            while (i < notes.length) {
                const note = notes[i];
                
                // è·³è¿‡è¿ç»­çš„ä¼‘æ­¢ç¬¦,åªä¿ç•™ä¸€ä¸ª
                if (note === '0') {
                    result.push('0');
                    while (i + 1 < notes.length && notes[i + 1] === '0') {
                        i++;
                    }
                } 
                // è·³è¿‡è¿ç»­çš„å»¶é•¿ç¬¦
                else if (note === '-') {
                    if (result.length > 0 && result[result.length - 1] !== '-') {
                        result.push('-');
                    }
                }
                // æ™®é€šéŸ³ç¬¦
                else {
                    result.push(note);
                }
                
                i++;
            }
            
            return result;
        }
        
        function formatJianpu(notes) {
            let formatted = '// è°ƒå·: C  æ‹å·: 4/4\n';
            formatted += '// å»ºè®®: ç”Ÿæˆç»“æœå¯èƒ½éœ€è¦æ‰‹åŠ¨è°ƒæ•´èŠ‚å¥å’ŒéŸ³é«˜\n\n';
            
            // æ¯è¡Œ8ä¸ªéŸ³ç¬¦(ä¾¿äºé˜…è¯»)
            for (let i = 0; i < notes.length; i += 8) {
                const line = notes.slice(i, i + 8);
                formatted += line.join(' ') + '\n';
            }
            
            return formatted;
        }
        
        function saveAsText() {
            try {
                const content = document.getElementById('jianpuEditor').value;
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'jianpu_' + Date.now() + '.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showStatus('æ–‡æœ¬æ–‡ä»¶å·²ä¿å­˜!', 'success');
            } catch (e) {
                showStatus('ä¿å­˜å¤±è´¥: ' + e.message, 'error');
                console.error('Save text error:', e);
            }
        }
        
        function saveAsMidi() {
            try {
                const content = document.getElementById('jianpuEditor').value;
                const midiData = convertToMidi(content);
                
                if (!midiData) {
                    throw new Error('MIDIè½¬æ¢å¤±è´¥');
                }
                
                const blob = new Blob([midiData], { type: 'audio/midi' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'jianpu_' + Date.now() + '.mid';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showStatus('MIDIæ–‡ä»¶å·²å¯¼å‡º! å¯å¯¼å…¥Logic Proä½¿ç”¨', 'success');
            } catch (e) {
                showStatus('MIDIå¯¼å‡ºå¤±è´¥: ' + e.message, 'error');
                console.error('Save MIDI error:', e);
            }
        }
        
        function convertToMidi(jianpuText) {
            try {
                // è§£æç®€è°±
                const lines = jianpuText.split('\n').filter(line => !line.startsWith('//') && line.trim());
                const noteEvents = [];
                let currentTime = 0;
                const ticksPerBeat = 480;
                const defaultDuration = ticksPerBeat; // å››åˆ†éŸ³ç¬¦
                
                lines.forEach(line => {
                    const symbols = line.split(/\s+/).filter(s => s);
                    
                    symbols.forEach(symbol => {
                        if (symbol === '0') {
                            // ä¼‘æ­¢ç¬¦
                            currentTime += defaultDuration;
                        } else if (symbol === '-') {
                            // å»¶é•¿ä¸Šä¸€ä¸ªéŸ³ç¬¦
                            if (noteEvents.length > 0) {
                                noteEvents[noteEvents.length - 1].duration += defaultDuration;
                            }
                            currentTime += defaultDuration;
                        } else {
                            // æ™®é€šéŸ³ç¬¦
                            const midiNote = jianpuToMidiNote(symbol);
                            if (midiNote >= 0 && midiNote <= 127) {
                                noteEvents.push({
                                    time: currentTime,
                                    note: midiNote,
                                    duration: defaultDuration,
                                    velocity: 80
                                });
                                currentTime += defaultDuration;
                            }
                        }
                    });
                });
                
                if (noteEvents.length === 0) {
                    throw new Error('æ²¡æœ‰æœ‰æ•ˆçš„éŸ³ç¬¦');
                }
                
                return createMidiFile(noteEvents, ticksPerBeat);
            } catch (e) {
                console.error('Convert to MIDI error:', e);
                throw e;
            }
        }
        
        function jianpuToMidiNote(symbol) {
            // ç§»é™¤æ‰€æœ‰æ ‡è®°,è·å–åŸºç¡€éŸ³ç¬¦
            const cleanSymbol = symbol.replace(/[Ì²Ì‡Ìˆ#]/g, '').replace(/[^\d]/g, '');
            
            // Cå¤§è°ƒç®€è°±åˆ°MIDIéŸ³ç¬¦çš„æ˜ å°„ (ä¸­å¤®C = 60)
            const baseNotes = {
                '1': 60,  // C4
                '2': 62,  // D4
                '3': 64,  // E4
                '4': 65,  // F4
                '5': 67,  // G4
                '6': 69,  // A4
                '7': 71   // B4
            };
            
            let midiNote = baseNotes[cleanSymbol];
            
            if (!midiNote) {
                return 60; // é»˜è®¤è¿”å›C4
            }
            
            // å¤„ç†å‡é™å·
            if (symbol.includes('#')) {
                midiNote += 1;
            }
            
            // å¤„ç†å…«åº¦
            if (symbol.includes('Ì²')) {
                midiNote -= 12; // ä½å…«åº¦
            } else if (symbol.includes('Ì‡')) {
                midiNote += 12; // é«˜å…«åº¦
            } else if (symbol.includes('Ìˆ')) {
                midiNote += 24; // è¶…é«˜å…«åº¦
            }
            
            // ç¡®ä¿åœ¨æœ‰æ•ˆèŒƒå›´å†…
            return Math.max(0, Math.min(127, midiNote));
        }
        
        function createMidiFile(noteEvents, ticksPerBeat) {
            // MIDIæ–‡ä»¶å¤´
            const header = [
                0x4D, 0x54, 0x68, 0x64, // "MThd"
                0x00, 0x00, 0x00, 0x06, // å¤´éƒ¨é•¿åº¦
                0x00, 0x00,             // æ ¼å¼0
                0x00, 0x01,             // 1ä¸ªéŸ³è½¨
                (ticksPerBeat >> 8) & 0xFF, ticksPerBeat & 0xFF  // æ¯æ‹çš„tickæ•°
            ];
            
            // åˆ›å»ºéŸ³è½¨æ•°æ®
            const trackEvents = [];
            
            // è®¾ç½®é€Ÿåº¦ (120 BPM)
            trackEvents.push(0x00, 0xFF, 0x51, 0x03, 0x07, 0xA1, 0x20);
            
            // æ·»åŠ éŸ³ç¬¦äº‹ä»¶
            let lastTime = 0;
            noteEvents.forEach(event => {
                const deltaTime = event.time - lastTime;
                const dtBytes = encodeVariableLength(deltaTime);
                
                // Note On
                trackEvents.push(...dtBytes, 0x90, event.note, event.velocity);
                
                // Note Off
                const durationBytes = encodeVariableLength(event.duration);
                trackEvents.push(...durationBytes, 0x80, event.note, 0x40);
                
                lastTime = event.time + event.duration;
            });
            
            // éŸ³è½¨ç»“æŸæ ‡è®°
            trackEvents.push(0x00, 0xFF, 0x2F, 0x00);
            
            // éŸ³è½¨å¤´
            const trackHeader = [
                0x4D, 0x54, 0x72, 0x6B, // "MTrk"
                (trackEvents.length >> 24) & 0xFF,
                (trackEvents.length >> 16) & 0xFF,
                (trackEvents.length >> 8) & 0xFF,
                trackEvents.length & 0xFF
            ];
            
            // ç»„åˆå®Œæ•´çš„MIDIæ–‡ä»¶
            return new Uint8Array([...header, ...trackHeader, ...trackEvents]);
        }
        
        function encodeVariableLength(value) {
            const bytes = [];
            bytes.push(value & 0x7F);
            value = value >> 7;
            
            while (value > 0) {
                bytes.unshift((value & 0x7F) | 0x80);
                value = value >> 7;
            }
            
            return bytes;
        }
        </script>
    </body>
</html>
